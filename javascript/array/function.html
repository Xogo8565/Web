<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>
    <body>
        <p>다음 중 좋아하는 과일의 이름을 적으시오.
            <p>딸기 / 파인애플 / 망고 / 사과</p>
            <input type="text" id="input" placeholder="과일 입력">
            <button type="button" id="btn">완료</button>
        </p>

        <script>
            let input = document.getElementById("input");
            let btn = document.getElementById("btn");

            //배열 생성 -> 특정 값이 그 배열의 몇번 인덱스에 있는지 확인
            /*
            indexOf(값): 값을 인자값으로 넘겨서 해당 배열의 가장 첫번째 값을 찾아 그 인덱스를 반환
            */
 /*
            let tempArr = ['파인애플', '망고', '딸기', '사과'];

            btn.onclick = function () {
                if (tempArr.indexOf(input.value) !== -1) {
                    alert(
                        "입력한 " + input.value + "는 배열의 " + tempArr.indexOf(input.value) +
                        "번 인덱스에 있습니다."
                    );
                } else {
                    alert("입력한 값이 존재하지 않습니다.");
                }
            }
 */
            /*
            concat(값/배열) : 값이나 배열을 결합해서 새로운 배열을 반환해주는 함수
            -> 원본 배열에 영향을 주지 않음
            */
           /*
            let arr1 = ["바나나", "딸기", "수박"];
            let arr2 = ["사과", "귤"];
            let arr3 = [10,20,30];
            
            let data1 = arr1.concat(arr2);
            console.log(data1);

            let data2 = arr1.concat("망고");
            console.log(data2);

            let data3 = arr1.concat(arr2,arr3);
            console.log(data3);

            console.log(arr1);
            */

            /*
            join(구분자) : 배열을 결합해 문자열로 반환
             -> 하나의 배열 안의 요소들을 모두 합쳐서 문자열로 반환
             -> 인자값이 없을 경우 ,를 기준으로 요소들을 결합
             -> 원본 배열은 영향받지 않음
            */
            /*
            let arr1 = ["바나나", "딸기", "수박"];
            let arr2 = ["사과", "귤"];
            let arr3 = [10,20,30];

            let data1 = arr1.concat(arr2,arr3);
            console.log(data1);

            let data2 = data1.join();
            console.log(data2);

            let data3 = data1.join("+");
            console.log(data3);
            */

            /*
            reverse : 배열의 순서를 뒤집어주는 함수
            -> 원본 데이터에 변화 o 
            */
           /*
            let arr1 = [1,2,3,4,5,6,7,8,9,10];
            let arr2 = ["가","나","다","라"];

            arr1.reverse();
            console.log(arr1);
            arr2.reverse();
            console.log(arr2);
            */
            /*
            sort : 배열안의 데이터를 오름차순 정렬 / 내림차순 정렬해주는 함수
            -> 인자값이 없이 사용됐을 때는 문자열을 기준으로 오름차순 정렬
            -> 원본 배열의 데이터에 영향 o 
            */
           /*
           let arr1 = ["가", "마" ,"나", "라", "다"];
           let arr2 = [5,1,3,10,9,6,8,2,4,7];
           arr1.sort();
           console.log(arr1);
           
           arr2.sort();
           //숫자의 경우 문자열로 변환되어 정렬이 이뤄지기 때문에 숫자로써의 올바른 정렬이 이뤄지지 않음
           console.log(arr2);
            */
           /*
           sort 함수의 인자값으로 compareFunction을 넘겨줘 오름차순, 내림차순으로 정렬할 수 있음
           
           compareFuction(a,b) 
           : 0보다 작은 수 반환(음수) -> a를 b보다 낮은 인덱스 정렬 : 오름차순
           compareFunction(a,b)
           : 0을 반환 -> a와 b의 인덱스를 변경하지 않음
           compareFunction(a,b)
           : 0보다 큰 수를 반환 -> a를 b보다 높은 인덱스 정렬 : 내림차순

           */
            /*
           function sortASC(a,b){
               return a-b;
           }
           function sortDESC(a,b){
                return b-a;
           }
           arr2.sort(sortASC);
           console.log(arr2);
           arr2.sort(sortDESC);
           console.log(arr2);

           function sortStringDESC(a,b){
               if(a<b){
                   return 1;
               } else if(a>b){
                   return -1;
               } else return 0;
           }

           arr1.sort(sortStringDESC);
           console.log(arr1);
           */

           /*
           push() : 배열의 가장 끝 인덱스에 새로운 값을 추가
           pop() : 배열의 가장 끝 인덱스에 있는 값 삭제
           원본 데이터에 영향을 줌
           */
           /*
           let fruit = ["apple","banana","mango"];
           fruit.push("strawberry");
           console.log(fruit);
           fruit.pop();
           console.log(fruit);
           */

           /*
           unshift(값): 배열의 첫 인덱스에 값 추가
           -> 원래 인덱스의 배열들은 뒤 인덱스로 모두 밀려남
           shift() : 배열의 첫 인덱스에 값 삭제
           */
           /*
           let fruit = ["apple","banana","mango"];
           fruit.unshift("watermelon");
           console.log(fruit);
           fruit.shift();
           console.log(fruit);
           */
          /*
           slice(인자1, 인자2) : 배열의 데이터를 잘라내는 함수
           배열에 값이 잘려진 상태를 반환
           인자1 -> 시작 인덱스
           시작 인덱스에서부터 데이터를 잘라서 자른 데이터를 배열로 만들어 반환
           인자2 -> 끝 인덱스
           시작 인덱스에서부터 데이터를 끝 인덱스 전까지 잘라서 배열로 반환
           
           -> 원본 배열에 영향 x
          */

          /*let fruit = ["apple","banana","mango","watermelon"];
          console.log(fruit.slice(1));
          console.log(fruit.slice(1,3));
          */

          /*
          splice(index, 제거수, [추가값])
          : 시작 인덱스를 기준으로 해서 원하는 개수만큼 데이터를 제거할 수 있음
          + 세번째 인자인 새로운 값을 추가하는 것도 가능
          시작 index : 해당 인덱스부터 제거(만약 index값만 넘겨주면 해당 인덱스부터 나머지 인덱스 데이터 모두 삭제)
          제거수 : 몇개의 인덱스를 삭제
          추가값 : 삭제한 요소의 자리에 새롭게 넣어줄 값
         
          */
        let fruit = ["apple","banana","mango","watermelon","grape"];
        //fruit.splice(1);
        //fruit.splice(1,2);
        //fruit.splice(1,2,"strawberry"); // 여러 개의 요소가 삭제 되도 새로운 값은 1번만 들어감
        //fruit.splice(0,0,"strawberrty");
        fruit.splice(-1,1);        
        console.log(fruit);


        </script>
    </body>
</html>